# *Фильтры*

В данном разделе находятся реализации низкочастотных фильтров для сигнала и их сравнение на основе RMSE.
Для тестов взят сигнал представляющий собой комбинацию синусоид с добавлением гауссовского шума на интервале 2 секунды с частотой дискретизации 15 кГц. Функция для генерации сигнала расположена в файле 
> synth_signal.py

## ***Фильтры низких частот***
## Masked FFT
Суть данного метода заключается в преобразовании временного ряда в частотный с помощью быстрого преобразования Фурье, с последующим обнулением необходимых частот. Затем выполняется обратное преобразование. Реализация представлена в файле

> masked_fft.py

в одноименной функции, в качестве параметров функции необходимо передавать исходный сигнал и максимальную частоту, которую необходимо срезать.

## Butterworth
Данный фильтр работает следующим образом: пропускаются сигналы определенных частот и подавляются сигналы других частот с минимальными искажениями в полосе пропускания. Реализация метода представлена в файле

> butter.py

в одноименной функции, в качестве параметров функции необходимо передавать исходный сигнал и максимальную частоту, которую необходимо срезать.
## FIRWIN
Данный фильтр был использован с оконной функцией Хэмминга, в качестве импульсной характеристики выбран sinc. Два этих параметра умножаются, в результате получается отфильтрованный сигнал. Реализация метода представлена в файле

> fir.py

в одноименной функции, в качестве параметров функции необходимо передавать исходный сигнал и максимальную частоту, которую необходимо срезать.
## ***Wavelet***
Вейвлет-преобразование — это метод анализа сигналов, который позволяет разложить сигнал на компоненты с различными уровнями детализации. отличие от преобразования Фурье, которое разлагает сигнал на синусоидальные компоненты, вейвлет-преобразование использует функции, называемые вейвлетами, которые локализованы как во времени, так и в частотной области.
Вейвлет — это функция с нулевым средним значением, локализованная во времени и частоте.
В качестве вейвлета взята функция Дебоши, так как она наиболее правильно передает поведение синтетического сигнала. Производится разложение сигнала на максимальное количество уровней. Затем происходит фрешхолдинг всех уровней кроме первого. Реализация данного метода представлена в файле

> wavelet.py

в одноименной функции, в качестве параметров функции необходимо передавать исходный сигнал.
## ***SSA***
Прежде чем работать с данным методом необходимо сделать свертку функции с помощью скользящего среднего (метод conv_signal представлен в файле ssa.py)
Затем мы преобразуем временной ряд в траекторную матрицу размером K * (N - K + 1), где K - размер окна, N - количество точек на временном ряду. Затем выполняется сингулярное разложение. Затем выполняется группировка значений, с последующим отбрасыванием шумовых компонент. Затем выполняется обратное преобразование. Реализация представлена в файле

> ssa.py

в одноименном методе, в качестве параметров используется свертка исходного сигнала.
## ***Скрытые Марковские модели***
В первую очередь временной ряд преобразуется в траекторную матрицу. Затем на основе полученной матрицы модель обучается, подбирая оптимальные параметры. Помимо этого мы подбираем лучшую модель на основе информационных критериев Байеса и Акаике. Реализация представлена в файле

> hmm.py

в одноименной функции, в качестве параметров функции необходимо передавать исходный сигнал.
## ***EMD***
Первым шагом данного метода является нахождение экстремумов функции. Затем мы интерполируем сигнал на основе минимумов и максимумов и вычисляем их среднее. Делаем это до тех пор пока разность между исходным сигналом и полученным средним не станет монотонным. Затем алгоритм повторяется до тех пор, пока полученная разница не станет трендом или шумом. Реализация представлена в файле

> emd.py

в одноименной функции, в качестве параметров функции необходимо передавать исходный сигнал.
## ***Сглаживания***
## **Скользящее среднее**
Принцип работы прост, мы выбираем окно длины n и каждою точку заменяем на матожидание по окну. Таким образом получаем сглаженный сигнал.  Реализация представлена в файле

> moving_avg.py

в одноименной функции, в качестве параметров функции необходимо передавать исходный сигнал.
## **Медианное сглаживание**
Медианное сглаживание работает аналогичным образом. Мы выбираем длину окна и считаем медиану по нему.
Реализация представлена в файле

> median_smoothing.py

в одноименной функции, в качестве параметров функции необходимо передавать исходный сигнал.
## **Экспоненциальное сглаживание**
Экспоненциальное сглаживание работает следующим образом. Начиная со второй точки мы берем текущее значение сигнала умноженное на параметр альфа и прибавляем предыдущий результат сглаженной функции умноженный на 1 - альфа. Реализация представлена в файле

> exponential_smooting.py

в одноименной функции, в качестве параметров функции необходимо передавать исходный сигнал.
## **Savgol**
Фильтр Савицкого-Голея является еще одной модификацией скользящего среднего, использующей МНК на окне нечетной длины.  Реализация представлена в файле

> savgol.py

в одноименной функции, в качестве параметров функции необходимо передавать исходный сигнал.


 


